<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Qrack: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qrack
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">General classical-emulating-quantum development framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Copyright (c) Daniel Strano 2017. All rights reserved. (See "qrack.hpp" for additional information.) Licensed under the GNU General Public License V3, (except where noted). See LICENSE.md in the project root or <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">https://www.gnu.org/licenses/gpl-3.0.en.html</a> for details.</p>
<p>This is a header-only, quick-and-dirty, multithreaded, universal quantum register simulation, allowing (nonphysical) register cloning and direct measurement of probability and phase, to leverage what advantages classical emulation of qubits can have.</p>
<p>To use: 1)#include "qrack.hpp" 2)Link against math and pthreads. (See build.sh for example.)</p>
<p>Instantiate a <a class="el" href="classQrack_1_1Register.html" title="The &quot;Qrack::Register&quot; class represents an independent quantum processor register. ...">Qrack::Register</a>, specifying the desired number of qubits. (Optionally, also specify the initial bit state in the constructor.)</p>
<p>PURE QUANTUM LOGIC:</p>
<p>Programs can be carried out in quantum computational logic on any register. See an online encyclopedia or a reference text for the function of the gates:</p>
<p>CCNOT(unsigned int control1, unsigned int control2, unsigned int target) - Doubly-controlled not</p>
<p>CNOT(unsigned int control, unsigned int target) - Controlled not</p>
<p>H(unsigned int bitIndex) - Hadamard</p>
<p>bool M(unsigned int bitIndex) - Measure (true for bit = 1)</p>
<p>bool MAll(unsigned int permutation) - Measure for overall bit permutation state of register. (True if match. Permutations are numbered from 0 to 2^[number of qubits in register].)</p>
<p>R1(double radians, unsigned int bitIndex) - Rotate around |1&gt; state*</p>
<p>R1Dyad(int numerator, int denominator, unsigned int bitIndex) - Rotate around |1&gt; state by an angle as a dyadic fraction, M_PI * numerator / denominator**</p>
<p>RX(double radians, unsigned int bitIndex) - Rotate around x axis*</p>
<p>RXDyad(int numerator, int denominator, unsigned int bitIndex) - Rotate around x axis by an angle as a dyadic fraction, M_PI * numerator / denominator**</p>
<p>RY(double radians, unsigned int bitIndex) - Rotate around y axis*</p>
<p>RYDyad(int numerator, int denominator, unsigned int bitIndex)- Rotate around y axis by an angle as a dyadic fraction, M_PI * numerator / denominator**</p>
<p>RZ(double radians, unsigned int bitIndex) - Rotate around z axis*</p>
<p>RZDyad(int numerator, int denominator, unsigned int bitIndex) - Rotate around z axis by an angle as a dyadic fraction, M_PI * numerator / denominator**</p>
<p>Swap(unsigned int bitIndex1, unsigned int bitIndex2) - Swap the values of bits at the two bit indices</p>
<p>X(unsigned int bitIndex) - Apply Pauli x matrix</p>
<p>Y(unsigned int bitIndex) - Apply Pauli y matrix</p>
<p>Z(unsigned int bitIndex) - Apply Pauli z matrix</p>
<p>CR1(double radians, unsigned int control, unsigned int target) - Controlled rotation around |1&gt; state.</p>
<p>CR1Dyad(int numerator, int denominator, unsigned int control, unsigned int target) - Controlled rotation around |1&gt; state by an angle as a dyadic fraction, M_PI * numerator / denominator**</p>
<p>CRX(double radians, unsigned int control, unsigned int target) - Controlled rotatation around x axis*</p>
<p>CRXDyad(int numerator, int denominator, unsigned int control, unsigned int target) - Controlled rotation around x axis by an angle as a dyadic fraction, M_PI * numerator / denominator**</p>
<p>CRY(double radians, unsigned int control, unsigned int target) - Controlled rotation around y axis*</p>
<p>CRYDyad(int numerator, int denominator, unsigned int control, unsigned int target)- Controlled rotation around y axis by an angle as a dyadic fraction, M_PI * numerator / denominator**</p>
<p>CRZ(double radians, unsigned int control, unsigned int target) - Rotate around z axis*</p>
<p>CRZDyad(int numerator, int denominator, unsigned int control, unsigned int target) - Controlled rotation around z axis by an angle as a dyadic fraction, M_PI * numerator / denominator**</p>
<p>CY(unsigned int control, unsigned int target) - Apply controlled Pauli y matrix</p>
<p>CZ(unsigned int control, unsigned int target) - Apply controlled Pauli z matrix</p>
<p>*Angles for radian rotations are Theta as in exp(-i * Theta), with "i" being the square root of -1. **Angles for dyadic fraction rotations are n/d as in exp(i * (M_PI * n) / d), with "i" being the square root of -1. Sign convention is opposite from other rotations.</p>
<p>PSEUDO QUANTUM LOGIC:</p>
<p>It is not possible to perform even certain trivial classical operations directly on a quantum computer, like simply copying the state of a register to another register! However, since we are only emulating a quantum computer, we want to be able to write in quantum logic, while leveraging the abilities of a classical computer to our (speed) advantage. (Complex types are just aliases for standard C++ double accuracy complex number types. See header for details.)</p>
<p>Register(Register orig) - Copy constructor that clones the exact state of the emulated register</p>
<p>CloneRawState(Complex16 output[registerBitLength]) - Output the raw state of the emulated register, including phase information</p>
<p>Prob(unsigned int bitIndex) - Get the probability that the bit is in the |1&gt; state, with maximum accuracy in one operation</p>
<p>ProbAll(unsigned int permutation) - Get the probability that the entire register is in the given permutation state, with maximum accuracy in one operation. (Permutations are numbered from 0 to 2^[number of qubits in register].)</p>
<p>OTHER METHODS:</p>
<p>unsigned int GetQubitCount() - Get the size of the register, in bits.</p>
<p>double Rand() - Generate a pseudo-random double, uniformly distributed from 0 to 1</p>
<p>EXAMPLE.CPP:</p>
<p>This is a simple example of quantum mechanics simulation in quantum computational logic. It is essentially a unidirectional binary quantum random walk algorithm, from a positive starting point, heading toward zero.</p>
<p>We assume a fixed length time step. During each time step, we step through an equal superposition of either standing still or taking one fixed length step from our current position toward our fixed destination.</p>
<p>This is equivalent to a physical body having a 50% chance of emitting a fixed unit of energy per a fixed unit of time, in a pure quantum state. Hence, it might be considered a simple quantum mechanics simulation. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
