Copyright (c) Daniel Strano 2017. All rights reserved. (See \char`\"{}qrack.\+hpp\char`\"{} for additional information.) Licensed under the G\+NU General Public License V3, (except where noted). See L\+I\+C\+E\+N\+S\+E.\+md in the project root or \href{https://www.gnu.org/licenses/gpl-3.0.en.html}{\tt https\+://www.\+gnu.\+org/licenses/gpl-\/3.\+0.\+en.\+html} for details.

This is a header-\/only, quick-\/and-\/dirty, multithreaded, universal quantum register simulation, allowing (nonphysical) register cloning and direct measurement of probability and phase, to leverage what advantages classical emulation of qubits can have.

To use\+: 1)\#include \char`\"{}qrack.\+hpp\char`\"{} 2)Link against math and pthreads. (See build.\+sh for example.)

Instantiate a \hyperlink{classQrack_1_1Register}{Qrack\+::\+Register}, specifying the desired number of qubits. (Optionally, also specify the initial bit state in the constructor.)

P\+U\+RE Q\+U\+A\+N\+T\+UM L\+O\+G\+IC\+:

Programs can be carried out in quantum computational logic on any register. See an online encyclopedia or a reference text for the function of the gates\+:

C\+C\+N\+O\+T(unsigned int control1, unsigned int control2, unsigned int target) -\/ Doubly-\/controlled not

C\+N\+O\+T(unsigned int control, unsigned int target) -\/ Controlled not

H(unsigned int bit\+Index) -\/ Hadamard

bool M(unsigned int bit\+Index) -\/ Measure (true for bit = 1)

bool M\+All(unsigned int permutation) -\/ Measure for overall bit permutation state of register. (True if match. Permutations are numbered from 0 to 2$^\wedge$\mbox{[}number of qubits in register\mbox{]}.)

R1(double radians, unsigned int bit\+Index) -\/ Rotate around $\vert$1$>$ state$\ast$

R1\+Dyad(int numerator, int denominator, unsigned int bit\+Index) -\/ Rotate around $\vert$1$>$ state by an angle as a dyadic fraction, M\+\_\+\+PI $\ast$ numerator / denominator$\ast$$\ast$

R\+X(double radians, unsigned int bit\+Index) -\/ Rotate around x axis$\ast$

R\+X\+Dyad(int numerator, int denominator, unsigned int bit\+Index) -\/ Rotate around x axis by an angle as a dyadic fraction, M\+\_\+\+PI $\ast$ numerator / denominator$\ast$$\ast$

R\+Y(double radians, unsigned int bit\+Index) -\/ Rotate around y axis$\ast$

R\+Y\+Dyad(int numerator, int denominator, unsigned int bit\+Index)-\/ Rotate around y axis by an angle as a dyadic fraction, M\+\_\+\+PI $\ast$ numerator / denominator$\ast$$\ast$

R\+Z(double radians, unsigned int bit\+Index) -\/ Rotate around z axis$\ast$

R\+Z\+Dyad(int numerator, int denominator, unsigned int bit\+Index) -\/ Rotate around z axis by an angle as a dyadic fraction, M\+\_\+\+PI $\ast$ numerator / denominator$\ast$$\ast$

Swap(unsigned int bit\+Index1, unsigned int bit\+Index2) -\/ Swap the values of bits at the two bit indices

X(unsigned int bit\+Index) -\/ Apply Pauli x matrix

Y(unsigned int bit\+Index) -\/ Apply Pauli y matrix

Z(unsigned int bit\+Index) -\/ Apply Pauli z matrix

C\+R1(double radians, unsigned int control, unsigned int target) -\/ Controlled rotation around $\vert$1$>$ state.

C\+R1\+Dyad(int numerator, int denominator, unsigned int control, unsigned int target) -\/ Controlled rotation around $\vert$1$>$ state by an angle as a dyadic fraction, M\+\_\+\+PI $\ast$ numerator / denominator$\ast$$\ast$

C\+R\+X(double radians, unsigned int control, unsigned int target) -\/ Controlled rotatation around x axis$\ast$

C\+R\+X\+Dyad(int numerator, int denominator, unsigned int control, unsigned int target) -\/ Controlled rotation around x axis by an angle as a dyadic fraction, M\+\_\+\+PI $\ast$ numerator / denominator$\ast$$\ast$

C\+R\+Y(double radians, unsigned int control, unsigned int target) -\/ Controlled rotation around y axis$\ast$

C\+R\+Y\+Dyad(int numerator, int denominator, unsigned int control, unsigned int target)-\/ Controlled rotation around y axis by an angle as a dyadic fraction, M\+\_\+\+PI $\ast$ numerator / denominator$\ast$$\ast$

C\+R\+Z(double radians, unsigned int control, unsigned int target) -\/ Rotate around z axis$\ast$

C\+R\+Z\+Dyad(int numerator, int denominator, unsigned int control, unsigned int target) -\/ Controlled rotation around z axis by an angle as a dyadic fraction, M\+\_\+\+PI $\ast$ numerator / denominator$\ast$$\ast$

C\+Y(unsigned int control, unsigned int target) -\/ Apply controlled Pauli y matrix

C\+Z(unsigned int control, unsigned int target) -\/ Apply controlled Pauli z matrix

$\ast$\+Angles for radian rotations are Theta as in exp(-\/i $\ast$ Theta), with \char`\"{}i\char`\"{} being the square root of -\/1. $\ast$$\ast$\+Angles for dyadic fraction rotations are n/d as in exp(i $\ast$ (M\+\_\+\+PI $\ast$ n) / d), with \char`\"{}i\char`\"{} being the square root of -\/1. Sign convention is opposite from other rotations.

P\+S\+E\+U\+DO Q\+U\+A\+N\+T\+UM L\+O\+G\+IC\+:

It is not possible to perform even certain trivial classical operations directly on a quantum computer, like simply copying the state of a register to another register! However, since we are only emulating a quantum computer, we want to be able to write in quantum logic, while leveraging the abilities of a classical computer to our (speed) advantage. (Complex types are just aliases for standard C++ double accuracy complex number types. See header for details.)

Register(\+Register orig) -\/ Copy constructor that clones the exact state of the emulated register

Clone\+Raw\+State(\+Complex16 output\mbox{[}register\+Bit\+Length\mbox{]}) -\/ Output the raw state of the emulated register, including phase information

Prob(unsigned int bit\+Index) -\/ Get the probability that the bit is in the $\vert$1$>$ state, with maximum accuracy in one operation

Prob\+All(unsigned int permutation) -\/ Get the probability that the entire register is in the given permutation state, with maximum accuracy in one operation. (Permutations are numbered from 0 to 2$^\wedge$\mbox{[}number of qubits in register\mbox{]}.)

O\+T\+H\+ER M\+E\+T\+H\+O\+DS\+:

unsigned int Get\+Qubit\+Count() -\/ Get the size of the register, in bits.

double Rand() -\/ Generate a pseudo-\/random double, uniformly distributed from 0 to 1

E\+X\+A\+M\+P\+L\+E.\+C\+PP\+:

This is a simple example of quantum mechanics simulation in quantum computational logic. It is essentially a unidirectional binary quantum random walk algorithm, from a positive starting point, heading toward zero.

We assume a fixed length time step. During each time step, we step through an equal superposition of either standing still or taking one fixed length step from our current position toward our fixed destination.

This is equivalent to a physical body having a 50\% chance of emitting a fixed unit of energy per a fixed unit of time, in a pure quantum state. Hence, it might be considered a simple quantum mechanics simulation. 